\documentclass[a4paper,
               12pt,
               BCOR12mm,
               ]{scrartcl}
%scrreport
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\title{APUVS, Blatt 1}
\author{Jan Fajerski and Kai Warncke and Magnus Müller}

\begin{document}
\maketitle  
  \section*{Aufgabe 1.3}
		Das Programm lässt sich nicht eindeutig einem Dwarf zuordnen. Wir identifizieren folgende
		Dwarfs in der Problemstellung:
    \begin{itemize}
%      \item [Dwarf 1] Die Daten sind als dich besetzter Vektor abgespeichert und die Arbeit wird durch das Aufteilen von kontinuierlichen Speicherstücke verteilt.
      \item [Dwarf 8] Summierung implementiert in diesem Fall eine Hashfunktion/Checksumme
      \item [Dwarf 10] Das Aufsummieren der Arrayelemente wird durch das Zerlegen in kleinere Teilprobleme parallelisiert.
    \end{itemize}
	%	\paragraph{Dwarf 1}
	%	*Ich bin mir nicht sicher, wie man den begründen kann. Vgl.
	%	\url{http://fluid.stanford.edu/~barad/teaching/cme212_winter2009/Lecture03.pdf}: Diese
	%	charakterisieren \emph{Dense Linear Algebra} als Komputation auf Matrizen
	%	(Matrixoperationen). Wir wenden hier ja eigentlich keine Matrixoperationen an, oder?*
		
		\paragraph{Dwarf 8}
		Vgl. hierzu \cite{wiki_hash}:
		\begin{quotation}
			A hash function is any well-defined procedure or mathematical function that converts
			a large, possibly variable-sized amount of data into a small datum, usually a single
			integer that may serve as an index to an array (cf. associative array). The values
			returned by a hash function are called hash values, hash codes, hash sums, checksums
			or simply hashes.
		\end{quotation}
		In diesem Sinne kann man das Aufsummieren der Feldelemente als Bildung einer
		Checksumme verstehen, was unter die Klasse der Kombinatorischen Algorithmen (Dwarf 8)
		fällt.

		\paragraph{Dwarf 10 - dynamic programming}
		Dwarf 10 wird in \cite[S. 16]{eecs} folgendermaßen charakterisiert:
		\begin{quotation}
			Computes a solution by solving simpler overlapping subproblems.
			Particularly useful in optimization problems with a large set of feasible
			solutions.
		\end{quotation}
		Das Aufteilen des Arrays in kleinere Stücke, auf denen dann jeweils das Problem gelöst
		wird, stellt also solch eine dynamische Programmierung dar.

  \section*{Aufgabe 1.4}

	\paragraph{a)} SIMD --- Die gleichen Instruktionen werden parallel auf verschiedenen
				Daten ausgeführt. --- \emph{data level parallelism.}
	\paragraph{b)} 
	Wie im Protokoll des Skripts \verb|call.sh| in Aufgabe 1.2 zu sehen, bringt in dieser
	Problemstellung die Parallelisierung keinen nennenswerten Vorteil (zumindest nicht,
	solange nicht die Problemgröße in Form der Größe des Arrays eine gewisse Grenze
	überschreitet). Daher könnte man sinnvollerweise das Problem durch eine \emph{SISD}
	Architektur umsetzen. Die Ausführung der Summation erfolgt also auf einer einzelnen
	Recheneinheit schneller als bei der Verteilung auf verschiedene Einheiten.
	
%	*meiner meinung nach bleibts bei SIMD...ist das einzige was sinn macht. oder fällt euch was anderes ein um die elemente zu summieren? man könnte das ganze natürlich sequentiell machen, also SISD, aber ob die das hören wollen. keine ahnung ob es irgend eine möglichkeit gibt das ganze mit ner MIMD architektur zu machen?*
%				*Magnus: mir fällt da auch nichts anderes ein. Ich denke nicht, dass es Sinn
%				macht, die Summation auf verschiedenen Recheneinheiten unterschiedlich zu
%				implementieren. Die Aufgabe bleibt ja die gleiche..*

		\nocite{*}
		\bibliographystyle{alphadin}
		\bibliography{bibliography.bib}

\end{document}
